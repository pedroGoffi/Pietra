#package "pietra.ast"
type ExprKind :: i64



EXPR_NONE                   :: 00
EXPR_INT                    :: 01
EXPR_FLOAT                  :: 02
EXPR_STRING                 :: 03
EXPR_NAME                   :: 04
EXPR_INIT_VAR               :: 05
EXPR_COMPOUND               :: 06
EXPR_FIELD                  :: 07
EXPR_COMPOUND_LIST_INDEXING :: 08
EXPR_COMPOUND_NAME          :: 09
EXPR_NEW                    :: 10
EXPR_UNARY                  :: 11
EXPR_BINARY                 :: 12
EXPR_CMP                    :: 13
EXPR_LOGIC                  :: 14
EXPR_CAST                   :: 15
EXPR_TERNARY                :: 16
EXPR_ARRAY_INDEX            :: 17
EXPR_CALL                   :: 18


Expr :: {
    kind:       ExprKind
    tkKind:     TokenKind
    int_lit:    i64
    name_lit:   cstr    
    lhs:        mut *i64 // Expr
    rhs:        mut *i64 // Expr
}

impl Expr {
    print :: (self: Self){    
        dump(self.kind)
        switch(self.kind){        
            case EXPR_INT: {                
                std.puts("<Int: ");            
                std.puts(std.itocstr(self.int_lit))
                std.puts(">\n")
            }
            case EXPR_NAME: {                
                std.puts("<Name: ")
                std.puts(self.name_lit)
                std.puts(">\n");
            }
            default: {
                std.puts("Idk how to print this...\n")
                dump(self.kind)
                exit(1)
            }
        }
    }
}

StmtKind :: enum {
    STMT_NONE
    STMT_EXPR
    STMT_IF
    STMT_SWITCH
    STMT_FOR
    STMT_WHILE
    STMT_RETUR
}

StmtVal :: union {}
Stmt :: {
    kind:   StmtKind
    as:     StmtVal
}

TypeSpecKind :: enum {
    TYPESPEC_NONE
    TYPESPEC_NAME
    TYPESPEC_POINTER
    TYPESPEC_ARRAY
    TYPESPEC_PROC
    TYPESPEC_CONST
    TYPESPEC_TEMPLAT
}

TypeSpecVal :: union {}
TypeSpec :: {    
    kind:   TypeSpecKind
    base:   *any
    as:     TypeSpecVal    
}

DeclKind :: enum {
    DECL_NONE
    DECL_VAR
    DECL_PROC
    DECL_AGGREGATE
    DECL_ENUM
    DECL_USE
    DECL_TYPE
    DECL_CONSTEXPR
    DECL_IMPL
}

DeclVal :: union {}
Decl :: {
    kind:   DeclKind
    name:   cstr
    as:     DeclVal
}


expr_init :: (kind: i64): *Expr {
    e: *Expr = std.allocate(sizeof(Expr));
    e.kind = kind;    
    return e;
}

expr_name   :: (name: cstr): *Expr {
    e: *Expr = expr_init(EXPR_NAME);
    e.name_lit = name;
    return e;    
}

expr_int    :: (num: i64): *Expr {
    e: *Expr = expr_init(EXPR_INT);
    e.int_lit = num;
    return e;    
}

expr_string :: (str: cstr): *Expr {
    e: *Expr    = expr_init(EXPR_STRING)
    e.name_lit  = str
    return e
}

expr_binary :: (kind: TokenKind, lhs: *Expr, rhs: *Expr){
    dump(kind)
    e: *Expr            = expr_init(EXPR_BINARY)
    e.tkKind            = kind
    // BUG: casting to avoid crashing
    e.lhs as mut *Expr  = lhs
    e.rhs as mut *Expr  = rhs
    return e
}
