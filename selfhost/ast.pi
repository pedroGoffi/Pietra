#package "pietra.ast"
type ExprKind :: i64

EXPR_NONE                       : i64 = iota()
EXPR_INT                        : i64 = iota()
EXPR_FLOAT                      : i64 = iota()
EXPR_STRING                     : i64 = iota()
EXPR_NAME                       : i64 = iota()
EXPR_INIT_VAR                   : i64 = iota()
EXPR_COMPOUND                   : i64 = iota()
EXPR_FIELD                      : i64 = iota()
EXPR_COMPOUND_LIST_INDEXING     : i64 = iota()
EXPR_COMPOUND_NAME              : i64 = iota()
EXPR_NEW                        : i64 = iota()
EXPR_UNARY                      : i64 = iota()
EXPR_BINARY                     : i64 = iota()
EXPR_CMP                        : i64 = iota()
EXPR_LOGIC                      : i64 = iota()
EXPR_CAST                       : i64 = iota()
EXPR_TERNARY                    : i64 = iota()
EXPR_ARRAY_INDEX                : i64 = iota()
EXPR_CALL                       : i64 = iota()


Expr :: {
    kind:       ExprKind
    int_lit:    i64
    name_lit:   cstr    
}


StmtKind :: enum {
    STMT_NONE
    STMT_EXPR
    STMT_IF
    STMT_SWITCH
    STMT_FOR
    STMT_WHILE
    STMT_RETUR
}
StmtVal :: union {}
Stmt :: {
    kind:   StmtKind
    as:     StmtVal
}

TypeSpecKind :: enum {
    TYPESPEC_NONE
    TYPESPEC_NAME
    TYPESPEC_POINTER
    TYPESPEC_ARRAY
    TYPESPEC_PROC
    TYPESPEC_CONST
    TYPESPEC_TEMPLAT
}

TypeSpecVal :: union {}
TypeSpec :: {    
    kind:   TypeSpecKind
    base:   *any
    as:     TypeSpecVal    
}

DeclKind :: enum {
    DECL_NONE
    DECL_VAR
    DECL_PROC
    DECL_AGGREGATE
    DECL_ENUM
    DECL_USE
    DECL_TYPE
    DECL_CONSTEXPR
    DECL_IMPL
}

DeclVal :: union {}
Decl :: {
    kind:   DeclKind
    name:   cstr
    as:     DeclVal
}


expr_init :: (kind: i64): *Expr {
    e: *Expr = std.allocate(sizeof(Expr));
    e.kind = kind;    
    return e;
}

expr_name   :: (name: cstr): *Expr {
    e: *Expr = expr_init(EXPR_NAME);
    e.name_lit = name;
    return e;    
}

expr_int    :: (num: i64): *Expr {
    e: *Expr = expr_init(EXPR_INT);
    e.int_lit = num;
    return e;    
}

expr_string :: (str: cstr): *Expr {
    e: *Expr    = expr_init(EXPR_STRING)
    e.name_lit  = str
    return e
}

expr_print :: (e: *Expr){    
    switch(e.kind){
        case 41: {
            dump(EXPR_INT)
            dump(e.kind)
            std.puts("ok")
        }
        default: {
            std.puts("Idk how to print this...\n")
            exit(1)
        }
    }
}