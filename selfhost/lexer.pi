#package "pietra.lexer"
use selfhost{token, ast, intern}
use selfhost{grammar}

StreamInfo ::  {
    stream: cstr
    token: *null // TODO
}

stream: cstr

init_stream :: (str: cstr){
    stream = str;
    next_token();    
}

isspace :: (n: i64): i64 {
    switch n {
        case ' ', '\t', '\n':   return true
        default:                return false
    }


}
skip_empty      :: (){
    while isspace(*stream) stream = stream + 1    
}
at_comment_begin :: (){
    return std.cstrncmp(stream, "//", 2) == 0
}
skip_comment    :: (){
    if at_comment_begin()
    {
        while not(*stream == '\0') + (*stream == '\n')
            stream = stream + 1
    }
    skip_empty();
    if(at_comment_begin()) skip_comment()
    
}

next_token      :: (){    
    skip_empty();
    skip_comment();           
    while isspace(*stream) stream = stream + 1
    token.start = stream; 

    switch *stream {        
        case 'a'...'z', 'A'...'Z', '_': {                        
            while is_keyword(*stream){                
                stream = stream + 1;
            }                           
            token.end = stream;
            stream = stream + 1
            token.kind = TK_NAME
            token.name = intern_range(token.start, token.end)                                    
            
        }    
        case '0'...'9': {
            while is_numeric(*stream){
                stream = stream + 1
            }
            token.end = stream;
            token.kind = TK_INT
            token.name = intern_range(token.start, token.end);
        }


        case '+': {
            std.puts("Got an token ADD == \n")            
            stream = stream + 1;
            token.kind = TK_ADD
            token.end = stream;
            token.name = intern_range(token.start, token.end);

        }

        case ',', '.': {
            stream = stream + 1;
            token.end = stream;
            token.name = intern_range(token.start, token.end);
            if *stream == ','{
                token.kind = TK_COMMA
            }
            else {
                token.kind = TK_DOT
            }
        }
        case '=': {
            token.kind = TK_EQ
            stream = stream + 1
            token.name = "="            
        }
        case ';': {
            token.kind = TK_DCOMMA
            stream = stream + 1
            token.name = ";"            
        }
        case ':': {
            token.kind = TK_DDOT
            token.name = ":"            
            stream = stream + 1            

            if *stream == ':' {                                
                token.name = "::"
                token.kind = TK_PREP                
                stream = stream + 1            
                
            }            
        }
        
        case '"': {
            token.kind  = TK_STRING            
            token.start = stream
            token.name  = scan_string() 
            token.end   = stream
            
        }
        case '{': {
            token.name = "{"
            stream = stream + 1
            token.kind = TK_OPEN_CURLY_BRACES
        }
        case '}': {
            token.name = "}"
            stream = stream + 1
            token.kind = TK_CLOSE_CURLY_BRACES
        }
        case '[': {
            token.name = "["
            stream = stream + 1
            token.kind = TK_OPEN_SQUARED_BRACES
        }
        case ']': {
            token.name = "]"
            stream = stream + 1
            token.kind = TK_CLOSE_SQUARED_BRACES
        }
        case '(': {
            stream = stream + 1
            token.kind = TK_OPEN_ROUND_BRACES
            token.name = "("
        }        
        case ')': {
            stream = stream + 1
            token.kind = TK_CLOSE_ROUND_BRACES
            token.name = ")"
        }
        case '\0': {
            token.kind = TK_EOF
            token.name = "EOF"
        }
        case ' ', '\n': {
            stream = stream + 1
            next_token()
        }

        default: {
            std.puts("Undefined token:\n\tascii == ");
            dump(*stream);            
            exit(1)
        }
    }    
}

is_numeric      :: (c: i64){
    switch c {
        case '0'...'9': return true
        default:        return false
    }
}
is_keyword      :: (c: i64){    
    switch c {
        case 'a'...'z', 'A'...'z', '_': return true    
        default:                        return false
    }
}
is_kind         :: (kind: i64){
    return token.kind == kind;
}
expects_kind    :: (kind: TokenKind): i64 {
    if token.kind == kind {
        next_token()
        return true
    }
    return false
}
// TODO
escape_to_char  :: (c: i64);
scan_string     :: (): *i8
{
    if *stream != '"' {
        std.puts("[ERROR]: expected string\n")
        exit(1)
    }    
    stream = stream + 1

    begin: cstr = stream        
    while *stream != '"' {
        if not *stream {
            std.puts("[ERROR - 1]: expected end of the string but got EOF\n")
            exit(1)    
        }

        stream = stream + 1    
    }    
    if *stream != '"' {
        std.puts("[ERROR]: expected end of the string but got EOF\n")
        exit(1)
    }    
    end: cstr = stream
    stream = stream + 1

    return intern_range(begin, end)    
}

scan_char       :: ();
scan_int        :: ();
scan_int_base   :: ();
scan_float      :: ();
char_to_int     :: ();

