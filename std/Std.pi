#package "std"
use std{Sys, Types, String}

STDIN       :: 0
STDERR      :: 2

S_IWUSR     :: 128
S_IRUSR     :: 256
S_IXUSR     :: 64
S_IWOTH     :: 2
S_IROTH     :: 4



exit :: (exit_code: i64) {
    syscall(exit_code, SYS_exit)
}

read :: (fd: i64, buf: *null, count: i64): i64 {
    return syscall(count, buf, fd, SYS_read)
}
write :: (fd: i64, ptr: *null, size: i64){
    syscall(size, ptr, fd, SYS_write)
}

brk :: (addr: *Addr_t): Addr_t {    
    return syscall(addr, SYS_brk)
}

sbrk :: (size: i64){    
    heap_end: *Addr_t = asm("mov rax, __heap_end__");
    *heap_end = *heap_end + size;
    brk(*heap_end)
    return *heap_end - size;
}
open :: (filename: cstr, flags: i64, mode: i64): i64 {    
    return syscall(mode, flags, filename, SYS_open)    
}

socket :: (domain: i64, type: i64, protocol: i64): i64 { 
    return syscall(protocol, type, domain, SYS_socket);
}
accept :: (sockfd: i64, addr: *any, addrlen: i64): i64 {
    return syscall(addrlen, addr, sockfd, SYS_accept);
}

bind :: (sockfd: i64, addr: *any, addrlen: i64): i64 {
    return syscall(addrlen, addr, sockfd, SYS_bind);    
}
listen :: (sockfd: i64, backlog: i64): i64 {
    return syscall(backlog, sockfd, SYS_listen)
}
fork :: (): i64{
    return syscall(SYS_fork);
}
execve :: (pathname: cstr, argv: *cstr, envp: *cstr): i64 
{    
    return syscall(envp, argv, pathname, SYS_execve);        
}
close :: (fd: i64) {
    return syscall(fd, SYS_close)
}
stoi :: (str: cstr): i64 {
    acc: i64 = 0;
    while *str {                
        acc = acc * 10 + *str - '0';
        str = str + 1;
    }
    return acc;
}
itos :: (x: i64): cstr {
    cap:  i64 = 32;
    buff: *i64 = sbrk(cap);
    size: i64 = 1;
    isNeg: i8 = 0;
            

    if x < 0 {
        x = x * -1;
        isNeg = 1;
    }


    buff[cap - size - 1] = x % 10 + '0';                        
    x = x / 10;        
    size = size + 1;   

    while x {        
        buff[cap - size - 1] = x % 10 + '0';                        
        x = x / 10;        
        size = size + 1;        
    }             

    if isNeg {
        buff[cap - size - 1] = '-';
        size = size + 1;
    }           
    i: i64 = 0;
    str: cstr = sbrk(size + 1);
    while i < size {
        str[i] = buff[32 - size + i];                        
        i = i + 1;
    }    
    return str;
}


fputs :: (fd: i64, str: cstr){     
    len: i64 = strlen(str)
    write(fd, str, len)    
}

fputi :: (fd: i64, x: i64): i64 {
    str: cstr = itos(x);
    fputs(fd, str);
}

eputs :: (str: cstr){
    fputs(STDERR, str)
}


puts :: (str: cstr){
    fputs(STDOUT, str)
}
puti :: (str: cstr){
    fputi(STDOUT, str)
}
putc :: (c: i64){
    s: cstr = sbrk(2);
    s[0] = c;
    s[1] = 0;
    puts(s);
}
input :: (msg: cstr): cstr {
    fputs(STDIN, msg);
    buff_cap: i64 = 256;
    
    buff: cstr = sbrk(buff_cap);
    len: i64 = read(STDIN, buff, buff_cap);
    buff[len - 1] = 0;            
    return buff;
}

streq :: (s1: cstr, s2: cstr): i64 {    
    len1: i64 = strlen(s1);

    if not(len1 == strlen(s2)) return false;
    
    i: i64 = 0;        
    while i < len1 {            
        if not(s1[i] == s2[i]) 
            return false
        i = i + 1
    }

    return true;
    
}
memcpy :: (dst: cstr, src: cstr, count: i64){
    i: i64 = 0;
    while i < count {
        dst[i] = src[i]        
        i = i + 1
    }
    dst[count] = 0
}


ARRAY_MAX_CAP :: sizeof(i64) * 100
Array :: {
    items:      *any
    size:       i64        
}

impl Array {    
    begin :: (self: *Array): *any{
        return self.items;
    }
    end :: (self: *Array): *any{
        return self.items + self.size * 8;
    }
    
    init :: (self: *Array){                        
        self.items      = sbrk(ARRAY_MAX_CAP)
        self.size       = 0;                
    }
    push :: (self: *Array, item: any){                    
        self.items[self.size] = item;
        self.size = self.size +  1;
    }    
    back :: (self: *Self): any {
        return self.items[self.size - 1];
    }
    len :: (self: *Self): i64 {
        return self.size;
    }
}
Array_new :: (): *Array {
    arr: *Array = sbrk(sizeof(Array));
    arr.init()
    return arr;    
}


Arena :: {
    blocks_end:     *null
    blocks_begin:   *null
    blocks:         Array    
    ptr:            *null    
}
std_arena: Arena
impl Arena {
    init :: (self: *Self){                            
        self.blocks.init()
        self.blocks_begin = self.blocks_end = self.blocks.begin()        
    }

    grow :: (self: *Self, size: i64) {                                
        self.ptr            = sbrk(size)            
        self.blocks_begin   = self.ptr        
        self.blocks_end     = self.ptr + size;                    
    }
    
    alloc :: (self: *Self, size: i64): *any {
        if not *self {
            self.init()
        }             

        if self.blocks_end - self.blocks_begin < size {            
            self.grow(size);            
        }                    
                        
        ptr: *any = self.ptr;    
        self.ptr = self.ptr + size;                
        
        return ptr;
    }

    free :: (self: *Self) {        
        i: *any = self.blocks_begin;
        
        while i < self.blocks_end {
            *i = 0;
            i = i + 8;
        }        
    }
}

InternString :: {    
    strings: *Array
    arena:  *Arena
}
std_intern_strings: InternString

impl InternString {
    init :: (self: *Self, arena: *Arena){                         
        self.strings = sbrk(sizeof(Array))
        self.strings.init()
        self.arena = arena                
        self.arena.init()        
    }    
        
        
    intern :: (self: *Self, str: cstr){                
        s: *cstr = self.strings.begin();
        while s < self.strings.end() {            
            intern: cstr = *s;
            puts("INTERN = ")
            puts(intern)
            puts("\n");
            if streq(intern, str) 
                return intern;
            s = s + 8;
        }       

        size: i64 = strlen(str);
        nstr: *cstr = self.arena.alloc(size + 1);
        memcpy(nstr, str, size);
        nstr[size] = '\0'
        self.strings.push(nstr);        
        return str;
    }
}

FILE :: {
    fd:     i64
    flags:  i64
    ptr:    *null    
    buffer_end, buffer_begin: *null
}
impl FILE {
    isOpen :: (self: *Self): i64 {        
        return 0 < self.fd
    }

    
    close :: (self: *Self) {
        close(self.fd)        
        self.ptr = self.buffer_end = self.buffer_begin = self.fd = self.flags = 0
    }
    
}
fnew  :: (): *FILE {
    fd: *FILE   = std_arena.alloc(sizeof(FILE));
    fd.ptr      = std_arena.alloc(500);
    return fd;
}
fopen :: (pathname: cstr, flags: cstr): *FILE {    
    _flags: i64 = -1;
    if streq(flags, "r"){        
        _flags = O_READONLY
    }
    elif streq(flags, "w"){        
        _flags = O_WRONLY
    }
    elif streq(flags, "r+"){    
        _flags = O_WRONLY | O_CREAT | O_READONLY
    }        

    file: *FILE = std_arena.alloc(sizeof(FILE));

    _mode: i64 = S_IROTH | S_IRUSR | S_IWOTH | S_IWUSR;
    file.fd = open(pathname, _flags, _mode);
    // NOTE: mmap the file
    file.buffer_begin = std_arena.alloc(4096);
    size: i64 = read(file.fd, file.buffer_begin, 4096);
    
    file.ptr = file.buffer_begin
    file.buffer_end = file.buffer_begin + size;
            
    return file;
}

// TODO: printf