SYS_READ    :: 0
SYS_WRITE   :: 1
SYS_OPEN    :: 2
SYS_CLOSE   :: 3
SYS_BRK     :: 12 
SYS_SOCKET  :: 41
SYS_ACCEPT  :: 43
SYS_BIND    :: 49
SYS_LISTEN  :: 50
SYS_EXIT    :: 60


STDIN       :: 0
STDOUT      :: 1
STDERR      :: 2

S_IWUSR     :: 128
S_IRUSR     :: 256
S_IXUSR     :: 64
S_IWOTH     :: 2
S_IROTH     :: 4
O_READONLY  :: 0
O_WRONLY    :: 1
O_RDWR      :: O_WRONLY | O_READONLY | O_CREAT
O_CREAT     :: 64
O_APPEND    :: 1024

SOCK_ADDR_SIZE  :: 16

AF_INET         :: 2
SOCK_STREAM     :: 1
INADDR_ANY      :: 0
MAX_CONN        :: 5

type cstr:: *i8
type Addr_t:: *i64

exit :: (exit_code: i64) {
    syscall(exit_code, SYS_EXIT)
}


strlen :: (str: cstr): i64{
    len: i64 = 0;
    while *str {        
        len = len + 1;
        str = str + 1;
    }    
    return len;
}
read :: (fd: i64, buf: *null, count: i64): i64 {
    return syscall(count, buf, fd, SYS_READ)
}
write :: (fd: i64, ptr: *null, size: i64){
    syscall(size, ptr, fd, SYS_WRITE)
}

brk :: (addr: *Addr_t): Addr_t {    
    return syscall(addr, SYS_BRK)
}

sbrk :: (size: i64){    
    heap_end: *Addr_t = asm("mov rax, __heap_end__");
    *heap_end = *heap_end + size;
    brk(*heap_end)
    return *heap_end - size;
}
open :: (filename: cstr, flags: i64, mode: i64): i64 {    
    return syscall(mode, flags, filename, SYS_OPEN)    
}

socket :: (domain: i64, type: i64, protocol: i64): i64 { 
    return syscall(protocol, type, domain, SYS_SOCKET);
}
accept :: (sockfd: i64, addr: *any, addrlen: i64): i64 {
    return syscall(addrlen, addr, sockfd, SYS_ACCEPT);
}

bind :: (sockfd: i64, addr: *any, addrlen: i64): i64 {
    return syscall(addrlen, addr, sockfd, SYS_BIND);
    return syscall(sockfd, addr, addrlen, SYS_BIND);
}
listen :: (sockfd: i64, backlog: i64): i64 {
    return syscall(backlog, sockfd, SYS_LISTEN)
}

close :: (fd: i64) {
    syscall(fd, SYS_CLOSE)
}
stoi :: (str: cstr): i64 {
    acc: i64 = 0;
    while *str {                
        acc = acc * 10 + *str - '0';
        str = str + 1;
    }
    return acc;
}
itos :: (x: i64): cstr {
    cap:  i64 = 32;
    buff: *i64 = sbrk(cap);
    size: i64 = 1;
    isNeg: i8 = 0;
    
    

    if x < 0 {
        x = x * -1;
        isNeg = 1;
    }


    buff[cap - size - 1] = x % 10 + '0';                        
    x = x / 10;        
    size = size + 1;   

    while x {        
        buff[cap - size - 1] = x % 10 + '0';                        
        x = x / 10;        
        size = size + 1;        
    }             

    if isNeg {
        buff[cap - size - 1] = '-';
        size = size + 1;
    }       
    
    i: i64 = 0;
    str: cstr = sbrk(size + 1);
    while i < size {
        str[i] = buff[32 - size + i];                        
        i = i + 1;
    }    
    return str;
}

fputs :: (fd: i64, str: cstr){     
    len: i64 = strlen(str)
    write(fd, str, len)
    
}
fputi :: (fd: i64, x: i64): i64 {
    str: cstr = itos(x);
    fputs(fd, str);
}

eputs :: (str: cstr){
    fputs(STDERR, str)
}

puts :: (str: cstr){
    fputs(STDOUT, str)
}
puti :: (str: cstr){
    fputi(STDOUT, str)
}

input :: (msg: cstr): cstr {
    fputs(STDIN, msg);
    buff_cap: i64 = 256;
    
    buff: cstr = sbrk(buff_cap);
    len: i64 = read(STDIN, buff, buff_cap);
    buff[len - 1] = 0;            
    return buff;
}
TK_EOF :: 9
TK_INT :: 2
TK_BOF :: 1
stream: cstr
token: ***any
TOKEN_SIZE      :: 40
TK_KIND         :: 0
TK_STR_START    :: 1
TK_STR_END      :: 2
TK_NAME         :: 3
TK_DIGIT        :: 4

init_lexer :: (){
    token               = sbrk(TOKEN_SIZE)
    token[TK_KIND]      = TK_BOF    
    token[TK_NAME]      = sbrk(1049 * 1049)
    token[TK_STR_START] = 0    
    token[TK_STR_END]   = 0    
    token[TK_DIGIT]     = 0
}
init_stream :: (str: cstr){
    stream = str;
    next()
}

streq :: (s1: cstr, s2: cstr): i64 {    
    len1: i64 = strlen(s1);
    if not(len1 == strlen(s2)) return false;
    i: i64 = 0;
    
    while i < len1 {
        if not(*s1 == *s2) return false;

        s1 = s1 + 1
        s2 = s2 + 1
        i = i + 1
    }

    return true;
    
}
memcpy :: (dst: cstr, src: cstr, count: i64){
    i: i64 = 0;
    while i < count {
        dst[i] = src[i]        
        i = i + 1
    }
    dst[count] = 0
}
prep_token :: (kind: i64, begin: cstr, end: cstr){
    token[TK_KIND]          = kind;
    token[TK_STR_START]     = begin;
    token[TK_STR_END]       = end
    size: i64 =  token[TK_STR_END] - token[TK_STR_START] 
    
    memcpy(token[TK_NAME], begin, size)
    token[TK_DIGIT] = stoi(token[TK_NAME])    
}
isIdentifierBegin :: (c: i64): i64 {
    return  ('a' - 1 < c)   +
            (c       < 'z') +
            (c == '_')
}
isNumeric :: (c: i64): i64 {
    return (('0' < c) + (c < '9')) == 2
}

next :: (){
    while *stream == ' ' stream = stream + 1

    begin: cstr = stream
    
    while not(*stream == 0) {
        
        if isNumeric(*stream) {            
            while isNumeric(*stream){
                stream = stream + 1;                
            }
            return prep_token(TK_INT, begin, stream)            
        }
            
        
        
        stream = stream + 1;
    }


    if *stream == 0 {        
        token[TK_KIND] = TK_EOF
        token[TK_NAME] = "<EOF>"
        return 0
    }
    
    puts("Invalid token: \n")
    puts(stream)
    exit(1)
    
}

main :: (argc: i64, argv: **i8){    
    if argc < 2 {
        puts("[ERROR]: usage: program <input>.\n")
        return 1
    }


    filepath: cstr = argv[1];

    fd: i64 = open(filepath, O_READONLY, 0);
    if fd == -2 {
        puts("ERROR: could not open the file: '");
        puts(filepath)
        puts("'\n")
        return 1
    }
    
    
    str_max_size: i64 = 1049 * 1049;
    str: cstr = sbrk(str_max_size);    
    endPos: i64 = read(fd, str, str_max_size);
    str[endPos] = 0;
    
    init_lexer()
    
    init_stream(str)

    out: i64 = open("out.pietra.bin", O_CREAT | O_RDWR, S_IWOTH | S_IROTH);
    while not (token[TK_KIND] == TK_EOF){                          
        if token[TK_KIND] == TK_INT {
            fputs(out, "\tpush ")
            fputi(out, token[TK_DIGIT])
            fputs(out, "\n")                        
        }

        if streq(token[TK_NAME], "69420"){
            puts("Oh yea\n")
        }


        next();
    }
    close(out)
    close(fd)
    puts(token[TK_NAME])    
    
}