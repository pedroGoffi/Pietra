
SYS_READ    :: 0
SYS_WRITE   :: 1
SYS_OPEN    :: 2
SYS_CLOSE   :: 3
SYS_BRK     :: 12 
SYS_EXIT    :: 60

STDOUT      :: 1

S_IWUSR     :: 128
S_IRUSR     :: 256
S_IXUSR     :: 64
S_IWOTH     :: 2
S_IROTH     :: 4
O_READONLY  :: 0
O_WRONLY    :: 1
O_RDWR      :: O_WRONLY | O_READONLY | O_CREAT
O_CREAT     :: 64
O_APPEND    :: 1024

type cstr       :: *i8
type Addr_t     :: *i64
type ptrdiff_t  :: *i64

exit :: (exit_code: i64) {
    syscall(exit_code, SYS_EXIT)
}


strlen :: (str: cstr): i64{
    
    len: i64 = 0;
    while *str {                
        len = len + 1;        
        str = str + 1;
        
    }    
    
    return len;
}
read :: (fd: i64, buf: *null, count: i64): i64 {
    return 
        syscall(count, buf, fd, SYS_READ)
}
write :: (size: i64, ptr: *null, fd: i64){
    syscall(size, ptr, fd, SYS_WRITE)
}

__heap_begin :: (): *i64 {
    return asm("mov rax, [__heap_begin__]");
}

__last_brk: *i64 = __heap_begin()
brk :: (addr: *null): Addr_t{        
    __last_brk = syscall(addr, SYS_BRK);                    
    return __last_brk;
}
sbrk :: (size: i64): *any {            
    return brk(__last_brk + size);        
}

alloc :: (size: i64, init_value: any): *any {    
    ptr: *any = sbrk(size);
    if ptr < 0{
        puts("[ERROR]: at alloc, invalid pointer:\n")
        dump(ptr)
        dump(-ptr)        
    }
    *ptr = init_value;
    return ptr;
}
fputs :: (fd: i64, str: cstr){     
    len: i64 = strlen(str)
    write(len, str, fd)
    
}
puts :: (str: cstr){
    fputs(STDOUT, str)
}
isdigit :: (c: i64): i64 {
    return (('0' < c) + (c < '9')) == 2;
}

open :: (filename: cstr, flags: i64, mode: i64): i64 {    
    return syscall(mode, flags, filename, SYS_OPEN)    
}


fd_getText :: (fd: *null): cstr{    
    ptr_len: i64 = 1024;
    ptr: cstr = alloc(ptr_len, 0);        
    read(fd, ptr, ptr_len);            
    return ptr;
}

close :: (fd: i64) {
    syscall(fd, SYS_CLOSE)
}

STR_SIZE    :: 16
type String :: *i64

STR_data :: (str: String){
    return (str + 0)
}
STR_size :: (str: String){
    return (str + 8)
}

STR_new ::(data: cstr): String {            
    ptr: *String = sbrk(STR_SIZE);            
    (*ptr)[0] = data;
    (*ptr)[1] = strlen(data);              
    return ptr;
}
type Token      :: *i64
TK_EOF          ::  1
TK_MOD          ::  2
TK_DOT          ::  3 
TK_DCOMMA       ::  4
TK_LT           ::  5
TK_PIPE         ::  6
TK_LTE          ::  7
TK_LAND         ::  8
TK_LOR          ::  9
TK_GT           ::  10
TK_ADD          ::  11
TK_AMPERSAND    ::  12
TK_SUB          ::  13
TK_DEC          ::  14
TK_NOT          ::  15
TK_INC          ::  16
TK_MULT         ::  17
TK_NOTE         ::  18
TK_INT          ::  19
TOKEN_SIZE      :: 40
stream: cstr
token: *Token = sbrk(TOKEN_SIZE)
init_stream :: (str: cstr){
    stream = str;
    next();
}

next :: (){
    begin: cstr = stream;

    if isdigit(*stream){
        lex_digit();
        return 0;
    }

    
    
}

lex_digit :: (){
    begin: cstr = stream;    
    (*token)[0] = TK_INT;
    (*token)[1] = begin;

    
    while(isdigit(*stream)){
        stream = stream + 1;
    }

    diff: ptrdiff_t = (:ptrdiff_t)(stream - begin);
    (*token)[2] = stream;

    val: i64 = 0;
    i: cstr = (:cstr)token[1];

    while i < token[2] {
        digit: i64 = '0' - *i % 10;
        dump(digit);

        
        i = i + 1;
    }
    
}


type Expr   :: *i64
EXPR_INT    :: 1
EXPR_BINARY :: 2
EXPR_STRING :: 3
EXPR_UNARY  :: 4
EXPR_SIZE   :: 32

EXPR_init   :: (kind: i64): *Expr{
    expr: *Expr = sbrk(EXPR_SIZE);
    (*expr)[0] = kind;    
    return expr;
}
EXPR_int    :: (n: i64): *Expr {
    expr: *Expr = EXPR_init(EXPR_INT);
    (*expr)[1] = n;
    return expr;
}
EXPR_binary :: (kind: i64, lhs: *Expr, rhs: *Expr): *Expr {
    expr: *Expr = EXPR_init(EXPR_BINARY);
    (*expr)[1] = lhs;
    (*expr)[2] = rhs;
    return expr;
}
EXPR_string :: (str: cstr): *Expr {
    expr: *Expr = EXPR_init(EXPR_STRING);
    (*expr)[1] = str;
    return expr;
}
EXPR_unary  :: (kind: i64, e: *Expr): *Expr {
    expr: *Expr = EXPR_init(EXPR_UNARY);
    (*expr)[1] = kind;
    (*expr)[2] = e;
    return expr;
}
print_expr :: (expr: *Expr) {
    kind: **i64 = expr[0];    

    if kind == EXPR_INT {        
        puts("Int: ");
        dump(expr[1]);
        return 0;
    }

    if kind == EXPR_BINARY {
        puts("(\n");
        puts("Binary\n");
        print_expr(expr[1])
        puts("<>\n");
        print_expr(expr[2])
        puts(")\n");
        return 0;
    }

    if kind == EXPR_STRING {
        puts("String = ");
        puts(expr[1]);
        puts("\n")
        return 0;
    }

    if kind == EXPR_UNARY {
        puts("(\n");
        puts("Unary ");
        dump(expr[1]);
        print_expr(expr[2]);
        puts(")\n");
        return 0;
    }
    
    puts("[ERR]: unknown expression.\n");
    exit(1);
    
}
type SVec       :: *i64
SVEC_SIZE       :: 64
SVEC_BLOCK_SIZE :: 4096 * 4096
SVec_new :: (): *SVec {
    vec: *SVec = sbrk(SVEC_SIZE);    
    (*vec)[0] = 0;  // data
    (*vec)[0] = nullptr;  // next
    return vec;
}
SVec_push :: (vec: *SVec, item: any): *SVec {
    data: *any = vec[1];
    dump(data);
    while vec[1] == nullptr{

    }
}
SVec_at  :: (vec: *SVec, pos: i64): *any {
    return ((:*any)*vec[1])[pos];
}
main :: (){        
    vec: *SVec = SVec_new();
    SVec_push(vec, 10);
}