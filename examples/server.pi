
SYS_READ    :: 0
SYS_WRITE   :: 1
SYS_OPEN    :: 2
SYS_CLOSE   :: 3
SYS_BRK     :: 12 
SYS_EXIT    :: 60

STDOUT      :: 1

S_IWUSR     :: 128
S_IRUSR     :: 256
S_IXUSR     :: 64
S_IWOTH     :: 2
S_IROTH     :: 4
O_READONLY  :: 0
O_WRONLY    :: 1
O_RDWR      :: O_WRONLY | O_READONLY | O_CREAT
O_CREAT     :: 64
O_APPEND    :: 1024

type cstr:: *i8
type Addr_t:: *i64

exit :: (exit_code: i64) {
    syscall(exit_code, SYS_EXIT)
}


strlen :: (str: cstr): i64{
    len: i64 = 0;
    while *str {        
        len = len + 1;
        str = str + 1;
    }    
    return len;
}
read :: (fd: i64, buf: *null, count: i64): i64 {
    return 
        syscall(count, buf, fd, SYS_READ)
}
write :: (size: i64, ptr: *null, fd: i64){
    syscall(size, ptr, fd, SYS_WRITE)
}

__heap_begin :: (): *i64 {
    return asm("mov rax, [__heap_begin__]");
}
brk :: (addr: Addr_t): i64 {
    return syscall(addr, SYS_BRK);
}
__heap_end: *i64 = 0
sbrk :: (size: i64): *any {            
    if __heap_end == 0 {        
        __heap_end = brk(0)

    }    
    __heap_end = __heap_end + size;
    brk(__heap_end)

    return __heap_end - size;
    
}

fputs :: (fd: i64, str: cstr){     
    len: i64 = strlen(str)
    write(len, str, fd)
    
}
puts :: (str: cstr){
    fputs(STDOUT, str)
}


open :: (filename: cstr, flags: i64, mode: i64): i64 {    
    return syscall(mode, flags, filename, SYS_OPEN)    
}


fd_getText :: (fd: *null): cstr{    
    ptr_len: i64 = 1024;
    ptr: cstr = sbrk(ptr_len);        
    read(fd, ptr, ptr_len);            
    return ptr;
}

close :: (fd: i64) {
    syscall(fd, SYS_CLOSE)
}

type Socket :: *i64
SA_sin_family :: (sock: Socket): *i64{
    return (sock + 8)
}
main :: (){
    p: *any = __builtin_buffer_alloc(10);
    
    
    
}