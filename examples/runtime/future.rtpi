FUTURE_DONE := 1 
FUTURE_THEN := 2 
Future      :: {
    m_left:     Future
    m_right:    Future
    m_data:     any
    m_cb:       proc(any): any
    m_id:       i64
}
// create a done instance of self 
impl Future data :: proc (self: *Self, data: any): *Self{
    self.m_data = data    
    self.m_id   = FUTURE_DONE
    return self
}
// create a then instanciate of self with a callback
impl Future then :: (self: *Self, cb: proc(any): any): *Self {            
    newft := Future()    
    newft.m_left    = self
    newft.m_cb      = cb
    newft.m_id      = FUTURE_THEN
    return newft
}
Future_poll :: (future: Future, data: any): any {    
    if      future.m_id == FUTURE_DONE return future.m_data
    elif    future.m_id == FUTURE_THEN {                

        if future.m_left {
            if result := Future_poll(future.m_left, 0) {
                future.m_right = future.m_cb(result)
                future.m_left  = None
            }
            return None
        }
        return future.m_right.poll(data)
    }

    print("[WARN]: Unhandled case in future poll")
}
impl Future poll :: (self: *Self, data: any): any {
    return Future_poll(self, data)
}
// awaits untill the current future is completed
impl Future wait :: (self: *Self): any {
    while true {
        result: any = Future_poll(self, 0)        
        if result return result
    }
    return self
}
impl Future run :: (self: *Self, future: Future): any {
    return future.wait()
}

impl Future gather :: (self: *Self, futures: Array): Array {
    quit := false 
    index: i64 = 0
    while quit == false {
        quit = true 
        
        while index < futures.size() {
            future: Future = futures.at(index)
            print("INDEX = ", index)
            if future.poll(0) == None {
                quit = false
            }
            index = index + 1            
        }                
    }

    return futures
}

ftex_1 :: (index: i64): Future {
    return Future()
        .data(index)        
        .then(proc (index: i64) { 
            print("Im THEN from index: ", index)    
            return index
        })        
        .then(proc (index: i64) {
            print("Im second THEN from index: ", index)    
            return "ok"
        })
}
ftex_2 :: (index: i64): Future {
    return Future()
        .data(index + 10)        
        .then(proc (index: i64) { 
            print("Hello, from the second future example ", index)    
            return index
        })                
}
main :: () {            
    print("[START]")
    futs:= make_array()
    i :=  0
    MAX: i64 = 10
    while i < MAX {
        futs.push(ftex_1(i))
        futs.push(ftex_2(i))
        
        
        i = i + 1
    }    
    
        
    Future().gather(futs)           
    print("[END]")
}